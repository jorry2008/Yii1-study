1.在reset回退到一个指定版本的时候，当前已经修改的内容将会丢失。
同checkout签出当前版本是一样的。
结论：使当前修改的内容丢失的情况有--
checkout签出
reset重置到指定版本

2.当内容已经被add到缓存区时，可以直接使用reset回退到当前版本即可辙消这个缓存修改。
注意：checkout可以清除当前的修改，但不能消除已经add到缓存区的内容。

3.另一个reset命令：
$ git reset HEAD readme.txt
即将指定文件的版本回退到当前的版本，
结果：一、辙消了已缓存的状态，二、未对文件内容作任何修改
所以上述命令是：清除已缓存状态与add相反

4.关于删除和恢复
使用git rm file时可以将已追踪的文件从git中删除掉，
此时文件处于删除状态，随后commit即可执行完这个删除并提交到新的版本库。
如果是误删，则可以git checkout -- 签出即可，
这个过程会导致修改内容丢失，而add过后的内容将保留。
一旦提交到版本库，修改当然没有了，缓存已经到了版本里面了

5.rm和reset两个命令的解释
当我对当前文件rm删除了之后，或者删除已经被提交
这个时候使用reset重置到上一个版本时，在目录下是看不到这个被删除的文件
为什么？
git提示如下：
$ git reset 8f4d2c0
Unstaged changes after reset:
D       readme.txt
D       test.txt
即删除的文件只是恢复了版本，并没有恢复曾经的状态（删除状态还在）
所以我们看不到删除的那些文件了。

我们尝试着得出如下结论：
使用reset跳转到另一个版本，或者进行版本切换时，
它能做的只是对commit命令的一个逆向过程，修改不会丢失。
所以说：
reset做的事情很单一，仅仅是切换了一个版本而已。
同理
checkout做的事情很单一，仅仅是将当前版本的文件签出到目录而已（必然会导致文件覆盖）。

注意：所有的reset都含有辙消缓冲的过程。


6.删除与文件丢失的情况
当一个文件修改后，不小心误删除了
一、假如这个文件被修改，删除，提交，那么我们可以
二、假如这个文件被修改，删除了，再回退当前HEAD版本，则修改的内容会丢失。








